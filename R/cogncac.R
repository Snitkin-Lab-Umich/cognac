#  -----------------------------------------------------------------------------
#' cogncac: Core Gene Alignement Concatenation
#  2019/07/15
#  Ryan D. Crawford
#  -----------------------------------------------------------------------------
#' @description 
#'   The cognac function idetentifies shared genes to be used as phylogenetic
#'   markers. Genes are aligned individually wth mafft and concatenates them
#'   into a single alignment.
#' @param fastaDir Directory containing the fasta files
#' @param featureDir Directory containing the Gff3 or genbank files 
#' @param fastaFiles In place of a directory with fasta files, a character 
#'   vector with the paths to the the fasta files for each genome can be
#'   input. Incompatible with "fasta dir."
#' @param fastaFiles In place of a directory with fasta files, a character 
#'   vector with the paths to the the fasta files for each genome can be
#'   input. Incompatible with "fasta dir."
#' @param featureFiles A character vector with a gff3 or genbank files
#'  for each genome
#' @param genomeIds Optional character vector with the unique ID for each 
#'   genome. If not supplied each genome is created by removing the file 
#'   extension from the fasta file.
#' @param geneEnv Optional. Environment created by "CreateGeneDataEnv", this
#'   allows a user to parse the genomic data ahead of time. This may be 
#'   useful when troubleshooting parameters with respect to the alignment
#'   or cd-hit clustering step.
#' @param outDir Directory to write the alignments, other output files, 
#'   and temp files created by cd-hit and mafft. Defaults to the current 
#'   working directory.
#' @param runId Optional string to prepend to the output files.
#' @param minGeneNum An integer specifing the minimum number of genes to
#'   use in creating the alignment. Default: 1.
#' @param outGroup Optional character vector of genomes IDs that are not used
#'   in selecting core genes. An out-group is useful for many phylogenetic 
#'   analysis, but the intersection of genes in all genomes in the analysis
#'   may be smaller if phylogenetically divergent genomes are included when 
#'   selecting core genes. This enables identification of a larger number of 
#'   core genes while still maintaining an outgroup for down-stream analysis.
#' @param maxMissGenes Optional double specifying what fraction of genes are
#'   permitted to be missing to be allowed to be included in the alignmnet.
#'   If an out-group is input these genomes are not removed.
#' @param coreGeneThresh Optional double specifying what fraction of genomes
#'   that a gene must occur in to be considered core. Defaults to 0.99.
#' @param copyNumTresh Optional double specifying what fraction of genomes
#'   that a gene can be duplicate in and remain in the analysis. If a gene
#'   is duplicated, the first gene is taken and used in the alignment.
#'   Defaults to 0.001 -- a gene can be duplicated in 1 in 1000 genomes. 
#' @param threadVal Number of threads available. Defaults to all available 
#'   threads. 
#' @param distMat Optional logical to create a distance matrix. If true, a
#'   distance matrix is calculated as the pairwise number of mutations 
#'   between genomes. Stored in the output environment as "distMat."
#' @param njTree Optional logical to create a neighbor joining tree with ape.
#'   returned in the output environment as "njTree." Defaults to false.
#' @param revTranslate Optional logical to to convert the aa alignment to dna.
#'   Defaults to false.
#' @param partitionFile Optional logical to create a partition file to input
#'   to RAxML
#' @param subModel Optional string for the type of substitution model 
#'   for partition file
#' @param keepTempFiles Optional logical to keep any temporary files 
#'   generated by mafft of cd-hit. 
#' @param percId Optional double for the identity threshold for identifying
#'   orthologous genes by cd-hit. See "-c" in the cd-hit manual. Defaults 
#'   to 0.7. 
#' @param algnCovg Optional double for the maximum disparity in the lenght
#'   of the genes to be considered orthologous by cd-hit. See -aL" in the
#'   cd-hit manual. Defaults to 0.8.
#' @param cdHitFlags Optional string with parameters to pass to cd-hit to 
#' define clusters aside from "-c" and "-aL" that can be used to define the
#'   clustering parameters.
#' @return An envrioment with the alignmnet data. Variables included
#'   by default are "aaAlgnPath" and "metaData"
#' @export
#  -----------------------------------------------------------------------------

cognac = function(
  fastaDir,       # Directory containing the fasta files
  featureDir,     # Directory containing the Gff3 or genbank files 
  fastaFiles,     # Fasta files for the input genomes
  featureFiles,   # Gff3 or genbank files for the input genomes
  fastaExt,       # Extension used on the fasta files
  featureExt,     # Extension used on the gff or genbank files 
  genomeIds,      # Vector of genomes to
  geneEnv,        # Optional. Environment created by "CreateGeneDataEnv"
  outDir,         # Optional. Directory to write the output files
  runId,          # Optional. Run ID to appent to output files
  minGeneNum,     # Optional. Minimium number of genes to build the tree
  maxMissGenes,   # Optional. maximum fraction of missing genes
  coreGeneThresh, # Optional. Fraction of genomes with gene to quality as core
  copyNumTresh,   # Optional. Fraction of genomes for a gene to be single copy
  threadVal,      # Optional. Number of threads available for mafft
  distMat,        # Optional. Bool to create a distance matrix
  njTree,         # Optional. Bool to create a neighbor joining tree
  revTranslate,   # Optional. Bool to convert the aa alignment to dna
  outGroup,       # Optional. Vector of genomes to exclude for gene selection
  partitionFile,  # Optional. Bool to write a partition file
  subModel,       # Optional. Type subsitiution model for partition file
  keepTempFiles,  # Optional. Bool to keep mafft and cd-hit files
  percId,         # Optional. Percent ID for the Cd-hit
  algnCovg,       # Optional. Percent alignment coverage for the Cd-hit
  cdHitFlags      # Optional. Parameters to pass to cd-hit to define clusters
  )
{
  startTime = Sys.time() # Start the timer
  # ---- Parse the input arguments ---------------------------------------------

  # Make sure that there aren't incompatible arguments with respect to 
  # fastaFiles and fastaDir
  if ( (!missing(fastaFiles) && !missing(fastaDir)) ||  
    (missing(fastaFiles) && missing(fastaDir))   
    )
  {
    stop(
      "Input arguments must contain one of \"fastaFiles\" (",
      "character vector with paths to fasta files)",
      " or \"fastaDir\"(directory containing fasta files)",
      )
    
  } else if ( missing(fastaFiles) ) {
    
    # Get the paths to the fasta files 
    fastaFiles = GetFilePaths( fastaDir, fastaExt )
  }
  
  # Make sure that there aren't incompatible arguments with respect to 
  # fastaFiles and fastaDir
  if ( ( !missing(featureFiles) && !missing(featureDir) ) ||  
    ( missing(featureFiles) && missing(featureDir) )   
    )
  {
    stop(
      "Input arguments must contain one of \"featureFiles\" (",
      "character vector with paths to fasta files)",
      " or \"featureDir\"(directory containing fasta files)",
      )
    
  } else if ( missing(featureFiles) ) {
    
    # Get the paths to the fasta files 
    featureFiles = GetFilePaths( featureDir, featureExt )
  }
  
  
  # Check that the size of the vectors are the same length
  if ( length(fastaFiles) != length(featureFiles) )
  {
    stop(
      "Input arguments must contain one of \"featureFiles\" (",
      "character vector with paths to gff or genbank files)",
      " or \"featureDir\"(directory containing gff or genbank files)",
      )
  }
  
  if ( length( fastaFiles ) == 0 )
    stop( "No fasta files were input..." )
  
  # Create the genome IDs and/or check the ids to ensre they are valid
  genomeIds = GetGenomeIds( 
    featureFiles, fastaFiles, fastaExt, featureExt, genomeIds
    )
  
  # If now output directory was specified, write to the working directory
  if ( missing(outDir) )
  {
    outDir = ''
  # Make sure the output directory ends in a '/'
  } else if ( !grepl("/$", outDir) && outDir != '' ) {
    outDir = paste0( outDir, '/' )
  }
 
  # If missing a run ID assign it to an empty string
  if ( missing( runId ) )
  {
    runId = ''
  # Check that the run ID ends in an underscore
  } else if ( !grepl("_$", runId) ) {
    runId = paste0( runId, '_')
  }
  
  # Make a temporary directory to store any files made during the run
  tempDir = paste0( outDir, runId, "temp_congnac_files/" )
  if ( !file.exists(tempDir) ) system( paste("mkdir", tempDir) )

  # By default, delete any temporary file that are created
  if ( missing(keepTempFiles) ) keepTempFiles = FALSE

  # Default to one available thread
  if ( missing(threadVal) ) threadVal = as.numeric( future::availableCores() )

  # Create a distance matrix with the pairwise distances between isolates
  if ( missing(distMat) ) distMat = FALSE

  # Set the bool ot create the neighbor joining tree
  if ( missing( njTree ) )
  {
    njTree = FALSE
  } else if ( njTree ) {
    distMat = TRUE
  }

  # By default do not make the RAxML partition file
  if ( missing(partitionFile) ) partitionFile = FALSE
  
  # By defautlt do not create the nt alignment 
  if ( missing(revTranslate) ) revTranslate = FALSE
  
  # ---- Set up multithreadding ------------------------------------------------

  # It's really dumb that you have to do this, but remove the limitation on the
  # maximum allowable object size by future sapplyf
  options( future.globals.maxSize = Inf )

  # Set up multithreadding via future
  plan = future::tweak( future::multiprocess, workers = threadVal )
  future::plan( plan )

  # Set the number of threads fot TBB
  RcppParallel::setThreadOptions( numThreads = threadVal )

  # ---- Find the target genes using the gene ids ------------------------------

  cat(
    "\n\nCreating concatenated gene alignment:\n",
    "  -- ", length(featureFiles), " genomes were input\n",
    "  -- Writing results to: ", outDir, "\n",
    "  -- Running on: ", threadVal, " cores\n",
    sep = ''
    )
  
  # Parse the input files. This creates an environment that stores:
  # genome ids, list of parsed gff files, a vector of amino acid sequences, 
  # and a vector with the gene Ids. Additionally, the amino acid sequences
  # are written to create the input file for cd-hit. 
  cat("\nStep 1: parsing the data on the input genomes\n")
  if ( missing( geneEnv ) )
    geneEnv = CreateGeneDataEnv( featureFiles, fastaFiles, genomeIds, tempDir )
  save( file = paste0( tempDir, "debug1.Rdata" ),  list = ls() )
  stepTime = GetSplit( startTime )
  
  # Identify orthologous genes with cd-hit
  cat("\nStep 2: finding orthologs with cd-hit\n")
  FindCogs( geneEnv, tempDir, percId, algnCovg, threadVal, cdHitFlags )
  save( file = paste0( tempDir, "debug3.Rdata" ),  list = ls() )
  stepTime = GetSplit( startTime )
  
  # Find the copy number of each gene. Any gene that is present in 
  # as multiple copies in greater than the "copyNumTresh" is removed 
  # from the analysis.
  cat("\nStep 3: filtering for single copy genes\n")
  FilterMultiCopyGenes( geneEnv, copyNumTresh )
  save( file = paste0( tempDir, "debug3.Rdata" ),  list = ls() )
  stepTime = GetSplit( stepTime )
  
  # Use the cd-hit results to identify a set of core genes present in all of
  # the input genomes.
  cat("\nStep 4: selecting genes to include in the alignment\n")
  SelectAlgnGenes( geneEnv, minGeneNum, coreGeneThresh, maxMissGenes, outGroup )
  save( file = paste0( tempDir, "debug4.Rdata" ),  list = ls() )
  stepTime = GetSplit( stepTime )
  
  # Individually create a new fasta file for each gene and generate the
  # alignment each gene with mafft
  cat("\nStep 5: aligning and concatenating orthologous genes\n")
  concatGeneFa = ConcatenateGeneAlgns( geneEnv, outDir, runId )
  save( file = paste0( tempDir, "debug5.Rdata" ),  list = ls() )
  stepTime     = GetSplit( stepTime )

  # Create the environment with the objects to export
  cat( "\nStep 6: creating output files\n" )
  algnEnv            = new.env()
  algnEnv$geneData   = CreateGeneMetaData( geneEnv, revTranslate )
  algnEnv$aaAlgnPath = concatGeneFa
  stepTime           = GetSplit( stepTime )
  
  cat("  -- Reverse translate:\n")
  # If requested, convert the AA alignment to DNA
  if ( revTranslate )
  {
    # Reverse translate the alignment and get the path to the newly 
    # created nt alignment
    concatGeneFa =
      ReverseTranslateAlgn( geneEnv, concatGeneFa, outDir, runId )
    
    # Assign the path to the nt alignment to the output environment
    algnEnv$ntAlgnPath = concatGeneFa
  }
  stepTime = GetSplit( stepTime )
  
  # If requested, create a distance matrix with the
  cat("  -- Distance matrix:\n")
  if ( distMat )
    algnEnv$distMat = CreateAlgnDistMat( concatGeneFa, "shared", FALSE )
  stepTime = GetSplit( stepTime )
  
  # If requested, make a neighbor joining tree with ape
  if ( njTree ) 
    algnEnv$njTree = ape::nj( as.dist(algnEnv$distMat) )

  # If requested, write a partition file with the positions of each
  # gene in the a lignment
  if ( partitionFile )
    CreatePartionFile( geneEnv, outDir, runId, subModel, seqType )
  
  # Remove any temp files
  if ( !keepTempFiles ) 
    system( paste( "rm -r", tempDir ) )
  stepTime = GetSplit( stepTime )
  
  cat( "\nRun complete\n" )
  cat( "  -- Amino acid alignment written to:", algnEnv$aaAlgnPath, '\n' )
  if ( revTranslate ) 
    cat( "  -- Nucleotide alignment written to:", algnEnv$ntAlgnPath, '\n' )
  endTime = GetSplit( startTime )
  cat( "\n\n" )
  
  return( algnEnv )
}

# ------------------------------------------------------------------------------